library(nnet
library(nnet
library(nnet)
library(nnet)
library(nnet)
pred_model <- df %>%
select(BusinessStartDate, Zip, BusinessType)
set.seed(1234)
train_index <- sample(nrow(pred_model), floor(0.7 * nrow(pred_model)))
data_train <- pred_model[train_index, ]
data_test <- pred_model[-train_index, ]
logistic_fit <- multinom(BusinessType ~ ., data = data_train)
pred_model <- df %>%
select(BusinessStartDate, Zip, BusinessType)
set.seed(1234)
train_index <- sample(nrow(pred_model), floor(0.7 * nrow(pred_model)))
data_train <- pred_model[train_index, ]
data_test <- pred_model[-train_index, ]
# Convert the BusinessType variable to a factor
data_train$BusinessType <- as.factor(data_train$BusinessType)
# Fit the multinomial logistic regression model with regularization
logistic_fit <- multinom(BusinessType ~ ., data = data_train, maxit = 100, trace = FALSE)
install.packages('glmnet')
library(glmnet)
library(glmnet)
library(glmnet)
library(glmnet)
library(glmnet)
# Convert the BusinessType variable to a factor
data_train$BusinessType <- as.factor(data_train$BusinessType)
# Create a matrix of predictor variables
x_train <- model.matrix(BusinessType ~ . - 1, data = data_train)
# Create a matrix of the dependent variable
y_train <- as.matrix(data_train$BusinessType)
# Fit the multinomial logistic regression model with regularization
logistic_fit <- glmnet(x_train, y_train, family = "multinomial")
View(data_train)
# Convert BusinessType to factor
data$BusinessType <- as.factor(data$BusinessType)
pred_mod <- df
# Convert BusinessType to factor
pred_mod$BusinessType <- as.factor(pred_mod$BusinessType)
# Split the data into training and testing sets
set.seed(123)
train_index <- sample(nrow(pred_mod), 0.7 * nrow(pred_mod))
train_data <- pred_mod[train_index, ]
test_data <- pred_mod[-train_index, ]
# Fit the logistic regression model
logistic_fit <- glm(BusinessType ~ BusinessStartDate + Latitude + Longitude, data = train_data, family = 'binomial')
View(pred_mod)
# Fit the logistic regression model
logistic_fit <- glm(BusinessType ~ BusinessStartDate + latitude + longitude, data = train_data, family = 'binomial')
# Fit the logistic regression model
logistic_fit <- glm(BusinessType ~ BusinessStartDate + latitude + longitude,
data = train_data, family = 'binomial', control = list(maxit = 50))
# Make predictions on the test set
predictions <- predict(logistic_fit, newdata = test_data, type = 'response')
pred_mod <- df
# Convert BusinessType to factor
pred_mod$BusinessType <- as.factor(pred_mod$BusinessType)
# Split the data into training and testing sets
set.seed(123)
train_index <- sample(nrow(pred_mod), 0.7 * nrow(pred_mod))
train_data <- pred_mod[train_index, ]
test_data <- pred_mod[-train_index, ]
train_data$BusinessStartDate <- substr(train_data$BusinessStartDate, 1, 4)
test_data$BusinessStartDate <- substr(test_data$BusinessStartDate, 1, 4)
View(train_data)
# Fit the logistic regression model
logistic_fit <- glm(BusinessType ~ BusinessStartDate + latitude + longitude,
data = train_data, family = 'binomial', control = list(maxit = 50))
# Make predictions on the test set
predictions <- predict(logistic_fit, newdata = test_data, type = 'response')
pred_mod <- df
# Convert BusinessType to factor
pred_mod$BusinessType <- as.factor(pred_mod$BusinessType)
# Split the data into training and testing sets
set.seed(123)
train_index <- sample(nrow(pred_mod), 0.7 * nrow(pred_mod))
train_data <- pred_mod[train_index, ]
test_data <- pred_mod[-train_index, ]
train_data$BusinessStartDate <- substr(train_data$BusinessStartDate, 1, 4)
test_data$BusinessStartDate <- substr(test_data$BusinessStartDate, 1, 4)
# Fit the logistic regression model
logistic_fit <- glm(BusinessType ~ BusinessStartDate + latitude + longitude,
data = train_data, family = 'binomial', control = list(maxit = 50))
# Make predictions on the test set
predictions <- predict(logistic_fit, newdata = test_data, type = 'response')
# Evaluate the model
confusion_matrix <- table(test_data$BusinessType, predictions > 0.5)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
print(paste0("Accuracy: ", round(accuracy * 100), "%"))
rm(list = ls())
rm(list = ls())
rm(list = ls())
rm(list = ls())
rm(list = ls())
pred_mod <- df %>%
substr(BusinessStartDate, 1, 4)
pred_mod <- df %>%
substr(BusinessStartDate, 1)
pred_mod <- df
# read csv file
df <- read.csv("data/hotels_motels.csv") %>%
separate(the_geom, into = c(NA, "longitude", "latitude"), sep = " ")
# remove parentheses from latitude and longitude columns
df$latitude <- gsub("\\(|\\)", "", df$latitude)
df$longitude <- gsub("\\(|\\)", "", df$longitude)
# convert latitude and longitude columns to numeric values
df$latitude <- as.numeric(df$latitude)
df$longitude <- as.numeric(df$longitude)
pred_mod <- df
pred_mod <- substr(pred_mod$BusinessStartDate, 1, 4)
View(df)
pred_model <- df
pred_model <- substr(pred_mod$BusinessStartDate, 1, 4)
pred_model <- substr(pred_model$BusinessStartDate, 1, 4)
pred_model <- df
pred_model <- substr(pred_model$BusinessStartDate, 1, 4)
pred_model <- df
pred_model$BusinessStartDate <- substr(pred_model$BusinessStartDate, 1, 4)
View(pred_model)
# Convert BusinessType to factor
pred_model$BusinessType <- as.factor(pred_model$BusinessType)
# Split the data into training and testing sets
set.seed(123)
train_index <- sample(nrow(pred_model), 0.7 * nrow(pred_model))
train_data <- pred_model[train_index, ]
test_data <- pred_mod[-train_index, ]
test_data <- pred_model[-train_index, ]
# Fit the logistic regression model
logistic_fit <- glm(BusinessType ~ BusinessStartDate + latitude + longitude,
data = train_data, family = 'binomial', control = list(maxit = 50))
# Make predictions on the test set
predictions <- predict(logistic_fit, newdata = test_data, type = 'response')
train_data$BusinessStartDate <- factor(train_data$BusinessStartDate)
test_data$BusinessStartDate <- factor(test_data$BusinessStartDate,
levels = levels(train_data$BusinessStartDate))
predictions <- predict(logistic_fit, newdata = test_data, type = 'response')
# Fit the logistic regression model
logistic_fit <- glm(BusinessType ~ BusinessStartDate + latitude + longitude,
data = train_data, family = 'binomial', control = list(maxit = 50))
# Make predictions on the test set
predictions <- predict(logistic_fit, newdata = test_data, type = 'response')
# Evaluate the model
confusion_matrix <- table(test_data$BusinessType, predictions > 0.5)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
print(paste0("Accuracy: ", round(accuracy * 100), "%"))
rm(list = ls())
# read csv file
df <- read.csv("data/hotels_motels.csv") %>%
separate(the_geom, into = c(NA, "longitude", "latitude"), sep = " ")
# remove parentheses from latitude and longitude columns
df$latitude <- gsub("\\(|\\)", "", df$latitude)
df$longitude <- gsub("\\(|\\)", "", df$longitude)
# convert latitude and longitude columns to numeric values
df$latitude <- as.numeric(df$latitude)
df$longitude <- as.numeric(df$longitude)
install.packages('caret')
library(tidyverse)
library(dplyr)
library(lubridate)
library(ggplot2)
library(viridis)
library(shiny)
library(leaflet)
library(tidytext)
library(tidyverse)
library(dplyr)
library(lubridate)
library(ggplot2)
library(viridis)
library(shiny)
library(leaflet)
library(tidytext)
library(tidyverse)
library(dplyr)
library(lubridate)
library(ggplot2)
library(viridis)
library(shiny)
library(leaflet)
library(tidytext)
library(caret)
library(caret)
library(caret)
data <- df
View(data)
data$BusinessStartDate <- substr(data$BusinessStartDate, 1, 4)
View(data)
data <- df
data$year <- substr(data$BusinessStartDate, 1, 4)
# Split data into training and testing sets
set.seed(123)
trainIndex <- createDataPartition(data$BusinessType, p = .8, list = FALSE)
training <- data[trainIndex,]
testing <- data[-trainIndex,]
# Train the model
model <- train(cbind(latitude, longitude) ~ year + businesstype,
method = "rpart",
data = training)
# Train the model
model <- train(cbind(latitude, longitude) ~ year + BusinessType,
method = "rpart",
data = training)
View(training)
# Train the model
model <- train(cbind(latitude, longitude) ~ year + BusinessType,
method = "rpart",
data = training)
library(tidyr)
library(tidyr)
# Train the model
model <- train(cbind(latitude, longitude) ~ year + BusinessType,
method = "rpart",
data = training)
View(testing)
View(training)
# Train the model
model <- train(cbind(latitude, longitude) ~ year,
method = "rpart",
data = training)
# Split data into training and testing sets
set.seed(123)
trainIndex <- createDataPartition(data$BusinessType, p = 0.8, list = FALSE)
training <- data[trainIndex, ]
testing <- data[-trainIndex, ]
# Train the model
model <- train(cbind(latitude, longitude) ~ year + BusinessType,
method = "rpart",
data = training)
# Split data into training and testing sets
set.seed(123)
trainIndex <- createDataPartition(data$BusinessType, p = 0.8, list = FALSE)
training <- data[trainIndex, ]
testing <- data[-trainIndex, ]
# Split the response variables
training$latitude <- as.numeric(training$latitude)
training$longitude <- as.numeric(training$longitude)
# Train the model separately for latitude and longitude
model_latitude <- train(latitude ~ year + BusinessType,
method = "rpart",
data = training)
model_longitude <- train(longitude ~ year + BusinessType,
method = "rpart",
data = training)
# Predict the future locations for each BusinessType
predictions_latitude <- predict(model_latitude, newdata = testing)
testing$year <- factor(testing$year, levels = levels(training$year))
# Predict the future locations for each BusinessType
predictions_latitude <- predict(model_latitude, newdata = testing)
predictions_longitude <- predict(model_longitude, newdata = testing)
# Print the predictions
cat("Predicted Latitude:\n")
print(predictions_latitude)
cat("\nPredicted Longitude:\n")
print(predictions_longitude)
View(model_longitude)
View(testing)
# Set the levels of 'year' in the testing dataset to match training dataset
testing$year <- factor(testing$year, levels = levels(training$year))
data <- df
data$year <- substr(data$BusinessStartDate, 1, 4)
# Split data into training and testing sets
set.seed(123)
trainIndex <- createDataPartition(data$BusinessType, p = 0.8, list = FALSE)
training <- data[trainIndex, ]
testing <- data[-trainIndex, ]
# Split the response variables
training$latitude <- as.numeric(training$latitude)
training$longitude <- as.numeric(training$longitude)
# Convert 'year' to character in both training and testing datasets
training$year <- as.character(training$year)
testing$year <- as.character(testing$year)
# Set the levels of 'year' in the testing dataset to match training dataset
testing$year <- factor(testing$year, levels = levels(training$year))
# Train the model separately for latitude and longitude
model_latitude <- train(latitude ~ year + BusinessType,
method = "rpart",
data = training)
model_longitude <- train(longitude ~ year + BusinessType,
method = "rpart",
data = training)
# Predict the future locations for each BusinessType
predictions_latitude <- predict(model_latitude, newdata = testing)
predictions_longitude <- predict(model_longitude, newdata = testing)
# Print the predictions
cat("Predicted Latitude:\n")
print(predictions_latitude)
cat("\nPredicted Longitude:\n")
print(predictions_longitude)
View(testing)
data <- df
data$year <- substr(data$BusinessStartDate, 1, 4)
# Split data into training and testing sets
set.seed(123)
trainIndex <- createDataPartition(data$BusinessType, p = 0.8, list = FALSE)
training <- data[trainIndex, ]
testing <- data[-trainIndex, ]
View(testing)
# Split the response variables
training$latitude <- as.numeric(training$latitude)
training$longitude <- as.numeric(training$longitude)
# Convert 'year' to character in both training and testing datasets
training$year <- as.character(training$year)
testing$year <- as.character(testing$year)
View(testing)
View(training)
# Train the model separately for latitude and longitude
model_latitude <- train(latitude ~ year + BusinessType,
method = "rpart",
data = training)
model_longitude <- train(longitude ~ year + BusinessType,
method = "rpart",
data = training)
View(training)
data <- df
data$year <- substr(data$BusinessStartDate, 1, 4)
# Split data into training and testing sets
set.seed(123)
trainIndex <- createDataPartition(data$BusinessType, p = 0.8, list = FALSE)
training <- data[trainIndex, ]
testing <- data[-trainIndex, ]
# Split the response variables
training$latitude <- as.numeric(training$latitude)
training$longitude <- as.numeric(training$longitude)
# Convert 'year' to character in both training and testing datasets
training$year <- as.Date(training$year)
testing$year <- as.Date(testing$year)
data <- df
View(data)
data$year <- substr(data$BusinessStartDate, 1, 4)
View(data)
# Split data into training and testing sets
set.seed(123)
trainIndex <- createDataPartition(data$BusinessType, p = 0.8, list = FALSE)
training <- data[trainIndex, ]
testing <- data[-trainIndex, ]
# Split the response variables
training$latitude <- as.numeric(training$latitude)
training$longitude <- as.numeric(training$longitude)
# Convert 'year' to character in both training and testing datasets
training$year <- as.numeric(training$year)
testing$year <- as.numeric(testing$year)
# Train the model separately for latitude and longitude
model_latitude <- train(latitude ~ year + BusinessType,
method = "rpart",
data = training)
model_longitude <- train(longitude ~ year + BusinessType,
method = "rpart",
data = training)
# Predict the future locations for each BusinessType
predictions_latitude <- predict(model_latitude, newdata = testing)
predictions_longitude <- predict(model_longitude, newdata = testing)
# Print the predictions
cat("Predicted Latitude:\n")
print(predictions_latitude)
cat("\nPredicted Longitude:\n")
print(predictions_longitude)
# Plot the predicted latitude and longitude
df_predictions <- data.frame(
Latitude = predictions_latitude,
Longitude = predictions_longitude
)
# Scatter plot of predicted latitude and longitude
ggplot(df_predictions, aes(x = Longitude, y = Latitude)) +
geom_point() +
labs(x = "Longitude", y = "Latitude") +
ggtitle("Predicted Business Locations")
View(df_predictions)
View(df_predictions)
install.packages('ggmap')
library(ggmap)
library(ggmap)
library(ggmap)
# Specify the latitude and longitude
lat <- predictions_latitude[1]
lng <- predictions_longitude[1]
# Reverse geocode to get the address
address <- revgeocode(c(lng, lat), output = "address")
result <- geocode(location = c(longitude, latitude), provider = "nominatim")
result <- geocode(location = c(lng, lat), provider = "nominatim")
# Reverse geocode to get the address
result <- reverse_geocode(location = c(lng, lat))
library(ggmap)
# Specify the latitude and longitude
lat <- predictions_latitude[1]
lng <- predictions_longitude[1]
# Reverse geocode to get the address
result <- reverse_geocode(location = c(lng, lat))
# Format the coordinates as a character string
location <- paste(lat, lng, sep = ",")
# Geocode to get the address
result <- geocode(location)
# Geocode to get the address
result <- geocode(location = c(longitude, latitude), provider = "nominatim")
# Geocode to get the address
result <- geocode(location, provider = "nominatim")
install.packages('osmdata')
library(osmdata)
library(osmdata)
# Specify the latitude and longitude
lat <- predictions_latitude[1]
lng <- predictions_longitude[1]
# Create a bounding box around the coordinates
bbox <- paste(lng - 0.001, lat - 0.001, lng + 0.001,
lat + 0.001, sep = ",")
# Query OpenStreetMap for the address within the bounding box
osm_data <- opq(bbox) %>%
add_osm_feature(key = "place") %>%
osmdata_sf()
# Extract the address from the result
address <- osm_data$osm_points$tags$name[1]
# Print the address
print(address)
bbox <- c(lng - 0.001, lat - 0.001, lng + 0.001, lat + 0.001)
# Query OpenStreetMap for the address within the bounding box
osm_data <- opq(bbox) %>%
add_osm_feature(key = "place") %>%
osmdata_sf()
# Extract the address from the result
address <- osm_data$osm_points$tags$name[1]
# Print the address
print(address)
View(osm_data)
# Specify the latitude and longitude
lat <- predictions_latitude[1]
lng <- predictions_longitude[1]
bbox <- c(lng - 0.001, lat - 0.001, lng + 0.001, lat + 0.001)
# Query OpenStreetMap for the address within the bounding box
osm_data <- opq(bbox) %>%
add_osm_feature(key = "place") %>%
osmdata_sf()
View(osm_data)
bbox <- c(lng - 0.002, lat - 0.002, lng + 0.002, lat + 0.002)
# Query OpenStreetMap for the address within the bounding box
osm_data <- opq(bbox) %>%
add_osm_feature(key = "place") %>%
osmdata_sf()
# Extract the address from the result
address <- osm_data$osm_points$tags$name[1]
# Print the address
print(address)
library(osmdata)
# Specify the latitude and longitude
lat <- predictions_latitude[1]
lng <- predictions_longitude[1]
bbox <- c(lng - 0.002, lat - 0.002, lng + 0.002, lat + 0.002)
# Query OpenStreetMap for the address within the bounding box
osm_data <- opq(bbox) %>%
add_osm_feature(key = "place") %>%
osmdata_sf()
# Extract the address from the result
address <- osm_data$osm_points$tags$name[1]
# Print the address
print(address)
print(lat)
print(lat, lng)
print(lat | lng)
print(lat & lng)
source("~/nola_words.R", echo=TRUE)
print(lat)
# Specify the latitude and longitude
lat <- predictions_latitude[1]
lng <- predictions_longitude[1]
print(lat)
print(lng)
raries
library(class)
library(class)
# Select the columns of interest
dataset <- df[, c("latitude", "longitude", "BusinessType")]
# Split the dataset into training and testing sets
set.seed(123) # Set seed for reproducibility
train1_indices <- sample(nrow(dataset), nrow(dataset)*0.7) # 70% for training
train1_data <- dataset[train1_indices, ]
test1_data <- dataset[-train1_indices, ]
# Set the number of neighbors for the KNN model
k <- 3
# Train the KNN model
knn_model <- knn(train1_data[, c("latitude", "longitude")],
test1_data[, c("latitude", "longitude")],
train1_data$BusinessType, k)
# Evaluate the model
accuracy <- sum(knn_model == test1_data$BusinessType) /
length(test1_data$BusinessType)
cat("Accuracy:", accuracy, "\n")
# Make predictions on new data
new_data <- data.frame(latitude = c(40.7128, 37.7749),
longitude = c(-74.0060, -122.4194))
predicted_types <- knn(train_data[, c("latitude", "longitude")], new_data,
train1_data$BusinessType, k)
predicted_types <- knn(train1_data[, c("latitude", "longitude")], new_data,
train1_data$BusinessType, k)
cat("Predicted Business Types:", predicted_types, "\n")
# Make predictions on new data
new_data <- data.frame(latitude = c(29.7128, 29.7749),
longitude = c(-90.0060, -90.4194))
predicted_types <- knn(train1_data[, c("latitude", "longitude")], new_data,
train1_data$BusinessType, k)
cat("Predicted Business Types:", predicted_types, "\n")
# Make predictions on new data
new_data <- data.frame(latitude = c(30.0168, 29.9749),
longitude = c(-90.0771, -90.1194))
predicted_types <- knn(train1_data[, c("latitude", "longitude")], new_data,
train1_data$BusinessType, k)
cat("Predicted Business Types:", predicted_types, "\n")
View(train1_data)
View(test1_data)
View(train1_data)
view(predicted_types)
view(predicted_types)
